package checker

import (
	"log"
	"regexp"
	"strconv"
	"strings"

	"github.com/frk/valid"
	"github.com/frk/valid/cmd/internal/config"
	"github.com/frk/valid/cmd/internal/rules/specs"
	"github.com/frk/valid/cmd/internal/rules/v2"
	"github.com/frk/valid/cmd/internal/search"
	"github.com/frk/valid/cmd/internal/types"
	"github.com/frk/valid/cmd/internal/types/global"
	"github.com/frk/valid/internal/cldr"
	"github.com/frk/valid/internal/tables"
)

var _ = log.Println

type Config struct {
	AST      *search.AST
	FieldKey *config.FieldKeyConfig
}

type FileInfo struct {
	Pkg    types.Pkg
	Import map[string]*PkgInfo
	// A map of regular expressions that need
	// to be registered in the file's init func.
	RxMap map[string]int
	Types []*TypeInfo
}

// The PkgInfo type holds info that will be used to generate an import spec.
type PkgInfo struct {
	// The package path.
	Path string
	// The package name.
	Name string
	// If set, it indicates that the name should be used
	// to specify the local name of the package.
	Local bool
	// The number of package's with the same name. This value
	// is used by those packages to modify their name in order
	// to not cause an import conflict.
	num int
}

type TypeInfo struct {
	// The Validtor struct being rule-checked.
	Validator *types.Validator
	// EnumMap maps types to their declared constants.
	EnumMap map[*types.Type][]types.Const
	// FKeyMap maps fields to their corresponding
	// keys as generated by the FieldKeyFunc.
	FKeyMap map[*types.StructField]string
	// FRefMap maps rule args of type ARG_FIELD_{ABS|REL}
	// to the fields that they are referencing.
	FRefMap map[*rules.Arg]*types.StructField
	// FRefChainMap maps rule args of type ARG_FIELD_{ABS|REL}
	// to the field chains that they are referencing.
	FRefChainMap map[*rules.Arg]types.FieldChain
	// FDepMap maps fields to a list of fields on which they depend.
	FDepMap map[*types.StructField][]*types.StructField
	// ChainMap maps each field to its corresponding field chain.
	ChainMap map[*types.StructField]types.FieldChain
	// VisibleChainMap maps each field to its shortest field chain.
	VisibleChainMap map[*types.StructField]types.FieldChain
	// ArgRuleMap maps args to the rules to which they belong.
	ArgRuleMap map[*rules.Arg]*rules.Rule
	// ArgIndexMap maps args to their respective index within the rule.
	ArgIndexMap map[*rules.Arg]int
	// RuleObjMap maps rules to the objects to which they belong.
	RuleObjMap map[*rules.Rule]*types.Obj
	// ObjFieldMap maps objects to the fields to which they belong.
	ObjFieldMap map[*types.Obj]*types.StructField
	// PtrMap maps objects to the pointers which point to them.
	PtrMap map[*types.Obj]*types.Obj
}

func Check(cfg Config, match *search.Match, fi *FileInfo) error {
	v := types.AnalyzeValidator(match.Named, cfg.AST)
	fi.Pkg = v.Type.Pkg

	ty := new(TypeInfo)
	ty.EnumMap = make(map[*types.Type][]types.Const)
	ty.FKeyMap = make(map[*types.StructField]string)
	ty.FRefMap = make(map[*rules.Arg]*types.StructField)
	ty.FRefChainMap = make(map[*rules.Arg]types.FieldChain)
	ty.FDepMap = make(map[*types.StructField][]*types.StructField)
	ty.ChainMap = make(map[*types.StructField]types.FieldChain)
	ty.VisibleChainMap = make(map[*types.StructField]types.FieldChain)
	ty.ArgRuleMap = make(map[*rules.Arg]*rules.Rule)
	ty.ArgIndexMap = make(map[*rules.Arg]int)
	ty.RuleObjMap = make(map[*rules.Rule]*types.Obj)
	ty.ObjFieldMap = make(map[*types.Obj]*types.StructField)
	ty.PtrMap = make(map[*types.Obj]*types.Obj)

	c := &checker{file: fi, ty: ty, v: v, ast: cfg.AST}
	c.newFKey = makeFKFunc(cfg.FieldKey)
	if err := c.run(); err != nil {
		return c.err(err, errOpts{})
	}

	ty.Validator = v
	fi.Types = append(fi.Types, ty)
	return nil
}

type checker struct {
	// Information the checker collected about
	// the file which will be generated.
	file *FileInfo
	// Information the checker collected about
	// the type being rule-checked.
	ty *TypeInfo
	// The Validtor struct being rule-checked.
	v *types.Validator
	// The function used for generating unique field keys.
	newFKey FieldKeyFunc
	// Reference to the AST, used for additional type
	// related info retrieval.
	ast *search.AST
}

func (c *checker) run() error {
	if err := c.walkType(c.v.Type); err != nil {
		return err
	}

	if err := c.checkObj(&types.Obj{Type: c.v.Type}); err != nil {
		return err
	}

	// TODO check for cyclic dependencies:
	// i.e., field F has rule arg that references field G
	// and field G has rule arg that references field F
	// should be disallowed....

	// If a global error handler was specified, which is
	// not local, then the file will need to import it.
	switch {
	case global.ErrorAggregator != nil:
		if pkg := global.ErrorAggregator.Pkg; pkg != c.v.Type.Pkg {
			c.file.addImport(pkg)
		}
	case global.ErrorConstructor != nil:
		if pkg := global.ErrorConstructor.Type.Pkg; pkg != c.v.Type.Pkg {
			c.file.addImport(pkg)
		}
	}
	return nil
}

func (c *checker) checkObj(o *types.Obj) error {
	if err := c.checkObjRules(o); err != nil {
		return err
	}

	switch t := o.Type; t.Kind {
	case types.PTR:
		return c.checkObj(t.Elem)
	case types.ARRAY, types.SLICE:
		return c.checkObj(t.Elem)
	case types.MAP:
		if err := c.checkObj(t.Key); err != nil {
			return err
		}
		if err := c.checkObj(t.Elem); err != nil {
			return err
		}
	case types.STRUCT:
		for _, f := range t.Fields {
			if f.CanSkip(c.v.Type.Pkg) {
				continue
			}

			if err := c.checkObj(f.Obj); err != nil {
				return c.err(err, errOpts{sf: f})
			}
		}
	}
	return nil
}

func (c *checker) checkObjRules(o *types.Obj) error {
	for _, r := range o.IsRules {
		if err := c.checkArgSpec(o, r); err != nil {
			return err
		}

		var err error
		switch r.Spec.Kind {
		case rules.REQUIRED:
			err = c.checkRequired(o, r)
		case rules.COMPARABLE:
			err = c.checkComparable(o, r)
		case rules.ORDERED:
			err = c.checkOrdered(o, r)
		case rules.LENGTH:
			err = c.checkLength(o, r)
		case rules.RANGE:
			err = c.checkRange(o, r)
		case rules.ENUM:
			err = c.checkEnum(o, r)
		case rules.FUNCTION:
			err = c.checkFunction(o, r)
		case rules.METHOD:
			err = c.checkMethod(o, r)
		case rules.OPTIONAL:
			err = c.checkOptional(o, r)
		case rules.REMOVE:
			// err = c.checkRemove(o, r)
		}
		if err != nil {
			return err
		}

		c.ty.RuleObjMap[r] = o

		if !c.hasCustomErrorHandler() {
			c.addDefaultErrorImport(r)
		}
	}

	for _, r := range o.PreRules {
		if r.Spec.Kind != rules.PREPROC {
			return &Error{C: E_PREPROC_INVALID, ty: o.Type, r: r}
		}

		if err := c.checkArgSpec(o, r); err != nil {
			return err
		}
		if err := c.checkPreprocessor(o, r); err != nil {
			return err
		}

		c.ty.RuleObjMap[r] = o
	}
	return nil
}

// Check that the number of arguments provided to the rule is allowed by the spec.
func (c *checker) checkArgSpec(o *types.Obj, r *rules.Rule) error {
	c.consolidateRuleArgs(r)

	if r.Spec.ArgMin > -1 && r.Spec.ArgMin > len(r.Args) {
		return &Error{C: E_RULE_ARGMIN, ty: o.Type, r: r}
	}
	if r.Spec.ArgMax > -1 && r.Spec.ArgMax < len(r.Args) {
		return &Error{C: E_RULE_ARGMAX, ty: o.Type, r: r}
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////
// spec.Kind specific rule checks

// checkRequired checks that the REQUIRED rule can be applied to the object.
func (c *checker) checkRequired(o *types.Obj, r *rules.Rule) error {
	// when "notnil" is used, the type must be nilable
	if r.Name == "notnil" && !o.Type.IsNilable() {
		return &Error{C: E_NOTNIL_TYPE, ty: o.Type, r: r}
	}

	// the "required" rule doesn't need any validation atm

	// If a "required" rule was specified on a struct type value, and
	// the struct type is not local, then the file will need to import
	// the struct type's package.
	if r.Name == "required" && o.Type.Kind == types.STRUCT {
		if o.Type.Pkg != c.v.Type.Pkg {
			c.file.addImport(o.Type.Pkg)
		}
	}
	return nil
}

// checkComparable checks that the rule's arguments can be converted
// to a Go value of a type that is *comparable* with the object's type.
func (c *checker) checkComparable(o *types.Obj, r *rules.Rule) error {
	for _, a := range r.Args {
		if !c.canConvertRuleArg(o, a) {
			return &Error{C: E_ARG_BADCMP, ty: o.Type, r: r, ra: a}
		}
	}
	return nil
}

// checkOrdered checks that the object's type is *ordered* and that the rule's
// arguments can be converted to a Go value of a type that is *comparable* with
// the object's type.
func (c *checker) checkOrdered(o *types.Obj, r *rules.Rule) error {
	// the type must be numeric or string
	if !o.Type.Kind.IsNumeric() && o.Type.Kind != types.STRING {
		return &Error{C: E_ORDERED_TYPE, ty: o.Type, r: r}
	}

	// rule args must be comparable with o.Type
	for _, a := range r.Args {
		if !c.canConvertRuleArg(o, a) {
			return &Error{C: E_ORDERED_ARGTYPE, ty: o.Type, r: r, ra: a}
		}
	}
	return nil
}

// checkLength checks that the object and rule can be used to generate a "length" rule.
func (c *checker) checkLength(o *types.Obj, r *rules.Rule) error {
	switch r.Name {
	case "len":
		// object type must have length
		if !o.Type.HasLength() {
			return &Error{C: E_LENGTH_NOLEN, ty: o.Type, r: r}
		}
	case "runecount":
		// object type must be string or byte slice
		if o.Type.Kind != types.STRING && !o.Type.IsBytesOrRunes() {
			return &Error{C: E_LENGTH_NORUNE, ty: o.Type, r: r}
		}

		// If a "runecount" rule is present, then the file
		// will need to import the unicode/utf8 package.
		c.file.addImport(types.Pkg{Path: "unicode/utf8"})
	}

	// Make sure that at least one arg was provided.
	if (len(r.Args) == 2 && r.Args[0].IsEmpty() && r.Args[1].IsEmpty()) ||
		(len(r.Args) == 1 && r.Args[0].IsEmpty()) {
		return &Error{C: E_LENGTH_NOARG, ty: o.Type, r: r}
	}

	// If two args were provided and both are uint values, then make
	// sure that those values represent valid lower to upper bounds.
	if len(r.Args) == 2 && r.Args[0].IsUInt() && r.Args[1].IsUInt() {
		bounds := [2]uint64{}
		for i, a := range r.Args {
			u64, err := strconv.ParseUint(a.Value, 10, 64)
			if err != nil {
				panic(err.Error()) // this shouldn't happen
			}
			bounds[i] = u64
		}

		if bounds[0] >= bounds[1] {
			return &Error{C: E_LENGTH_BOUNDS, ty: o.Type, r: r}
		}
		return nil
	}

	for _, a := range r.Args {
		switch {
		case a.Type == rules.ARG_UNKNOWN:
			continue

		// If the argument is a field then make sure that that field's
		// type can be converted to an int, which is the type of the
		// return value of the `len` and `ut8.RuneCount` functions.
		case a.IsFieldRef():
			tt := &types.Type{Kind: types.INT}
			ft := c.ty.FRefMap[a].Obj.Type // field's type
			if !ft.IsConvertibleTo(tt) {
				return &Error{C: E_LENGTH_ARGTYPE, r: r, ra: a}
			}
			continue

		case !a.IsUInt():
			return &Error{C: E_LENGTH_ARGTYPE, r: r, ra: a}
		}
	}

	// TODO-maybe: based on arg combination
	// link the ErrOpts[<args>] to the rule.
	return nil
}

// checkRange checks that the object and rule can be used to generate a "range" rule.
func (c *checker) checkRange(o *types.Obj, r *rules.Rule) error {
	// object type must be numeric
	if !o.Type.Kind.IsNumeric() {
		return &Error{C: E_RANGE_TYPE, ty: o.Type, r: r}
	}

	// Make sure that both args were provided.
	if r.Args[0].IsEmpty() || r.Args[1].IsEmpty() {
		return &Error{C: E_RANGE_NOARG, ty: o.Type, r: r}
	}

	// The rule's args must be comparable to the object's type.
	for _, a := range r.Args {
		if !c.canConvertRuleArg(o, a) {
			return &Error{C: E_RANGE_ARGTYPE, ty: o.Type, r: r, ra: a}
		}
	}

	// If both args are numeric constants, then make sure
	// that the values represent valid upper to lower bounds.
	if r.Args[0].IsNumeric() && r.Args[1].IsNumeric() {
		bounds := [2]float64{}
		for i := range r.Args {
			f64, err := strconv.ParseFloat(r.Args[i].Value, 64)
			if err != nil {
				panic(err.Error()) // shouldn't happen
			}
			bounds[i] = f64
		}
		if bounds[0] >= bounds[1] {
			return &Error{C: E_RANGE_BOUNDS, ty: o.Type, r: r}
		}
	}
	return nil
}

// checkEnum checks that the "enum" rule can be applied to the object's type.
func (c *checker) checkEnum(o *types.Obj, r *rules.Rule) error {
	if len(o.Type.Name) == 0 {
		return &Error{C: E_ENUM_NONAME, ty: o.Type, r: r}
	}
	if !o.Type.Kind.IsBasic() {
		return &Error{C: E_ENUM_KIND, ty: o.Type, r: r}
	}

	// Make sure that the type actually has some accessible constants declared.
	consts := c.ty.EnumMap[o.Type]
	if len(consts) == 0 {
		return &Error{C: E_ENUM_NOCONST, ty: o.Type, r: r}
	}

	// If an ENUM rule is present, which has constants declared in
	// packages other than the validator's package, then the file
	// will need to import each constant's package.
	for _, k := range consts {
		if k.Pkg != c.v.Type.Pkg {
			c.file.addImport(k.Pkg)
		}
	}
	return nil
}

// checkFunction checks that the object can actually be passed as argument
// to the function. It also checks that the rule arguments can be passed as
// function arguments. In addition to that, if the function belongs to one
// of the included github.com/frk/valid rules, the checker will check the
// validity of the rule's arguments (where possible).
func (c *checker) checkFunction(o *types.Obj, r *rules.Rule) error {
	// Check if an instance of the object can be passed
	// to the function as its first argument.
	fn := specs.GetFunc(r.Spec)
	p := fn.Type.In[0].Type
	if fn.Type.IsVariadic && len(fn.Type.In) == 1 {
		p = p.Elem.Type
	}
	if !o.Type.IsConvertibleTo(p) {
		return &Error{C: E_FUNCTION_INTYPE, ty: o.Type, r: r}
	}

	// Check that the arguments specified in the rule tag can be used
	// as the arguments for the corresponding function parameters.
	if err := c.canUseRuleArgsAsFuncParams(r); err != nil {
		return c.err(err, errOpts{C: E_FUNCTION_ARGTYPE, ty: o.Type})
	}

	// Some included functions accept arguments of a known set of valid
	// values, check that the rule argument's values belong to that set.
	if fn.Type.IsIncluded() {
		if err := c.checkIncludedRuleArgValues(r); err != nil {
			return c.err(err, errOpts{C: E_FUNCTION_ARGVALUE, ty: o.Type})
		}
	}

	// If a FUNCTION rule is present with a non-local function,
	// then the file will need to import the function's package.
	if fn.Type.Pkg != c.v.Type.Pkg {
		c.file.addImport(fn.Type.Pkg)
	}
	return nil
}

// checkMethod checks that the object can be used to
// generate a call to the rule's method, e.g. "IsValid".
func (c *checker) checkMethod(o *types.Obj, r *rules.Rule) error {
	// Check that o implements a method that matches the rule type.
	var found bool
	for _, m := range o.Type.MethodSet {
		if m.Name != r.Spec.Func.Name {
			continue
		}
		fn := specs.GetFunc(r.Spec)
		if !m.Type.IsIdenticalTo(fn.Type) {
			continue
		}

		found = true
		break
	}
	if !found {
		return &Error{C: E_METHOD_TYPE, ty: o.Type, r: r}
	}

	// Check that the arguments specified in the rule tag can be used
	// as the arguments for the corresponding method parameters.
	if err := c.canUseRuleArgsAsFuncParams(r); err != nil {
		// TODO would be nice to have a test case for this
		// but for that I'd need to add other METHOD rules
		// since currently there's only one and that one
		// takes no input arguments.
		return err
	}

	return nil
}

// checkOptional checks that the use of the optional rule is sound.
func (c *checker) checkOptional(o *types.Obj, r *rules.Rule) error {
	if r.Name == "optional" {
		for _, r2 := range o.IsRules {
			if r2.Name == "required" || r2.Name == "notnil" {
				return &Error{C: E_OPTIONAL_CONFLICT, ty: o.Type, r: r, r2: r2}
			}
		}
	}
	if r.Name == "omitnil" {
		for _, r2 := range o.IsRules {
			if r2.Name == "notnil" {
				return &Error{C: E_OPTIONAL_CONFLICT, ty: o.Type, r: r, r2: r2}
			}
		}
	}
	return nil
}

// checkPreprocessor checks that the object can be passed as argument to the preprocessor
// function and that that function's result can, in turn, be assigned to the object.
func (c *checker) checkPreprocessor(o *types.Obj, r *rules.Rule) error {
	// Make sure that an instance of o can be passed
	// to the function as its first argument.
	fn := specs.GetFunc(r.Spec)
	paramType := fn.Type.In[0].Type
	if fn.Type.IsVariadic && len(fn.Type.In) == 1 {
		paramType = paramType.Elem.Type
	}
	if !o.Type.IsConvertibleTo(paramType) {
		return &Error{C: E_PREPROC_INTYPE, ty: o.Type, r: r}
	}

	// Make sure that an instance of the function
	// output type can be assign to o.
	outputType := fn.Type.Out[0].Type
	if !outputType.IsConvertibleTo(o.Type) {
		return &Error{C: E_PREPROC_OUTTYPE, ty: o.Type, r: r}
	}

	// Check that the arguments specified in the rule tag can be used
	// as the arguments for the corresponding function's parameters.
	if err := c.canUseRuleArgsAsFuncParams(r); err != nil {
		return c.err(err, errOpts{C: E_PREPROC_ARGTYPE, ty: o.Type})
	}

	// If a PREPROC rule is present with a non-local function,
	// then the file will need to import the function's package.
	if fn.Type.Pkg != c.v.Type.Pkg {
		c.file.addImport(fn.Type.Pkg)
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////
// helpers

// canConvertRuleArg reports whether or not the rule argument's
// literal value can be converted to the object's type.
func (c *checker) canConvertRuleArg(o *types.Obj, a *rules.Arg) bool {
	if a.IsFieldRef() {
		f := c.ty.FRefMap[a]

		// If obj's type is a pointer and the referenced field's type
		// is identical to the pointer's base, then accept because the
		// generator can use deref expression.
		if o.Type.Kind == types.PTR {
			if o.Type.Elem.Type.IsIdenticalTo(f.Obj.Type) {
				return true
			}
		}

		return f.Obj.Type.IsConvertibleTo(o.Type)
	}

	// obj type is interface{} or string, accept
	if o.Type.IsEmptyIface() || o.Type.Kind == types.STRING {
		return true
	}

	// arg is unknown, accept
	if a.Type == rules.ARG_UNKNOWN {
		return true
	}

	// both are booleans, accept
	if o.Type.Kind == types.BOOL && a.Type == rules.ARG_BOOL {
		return true
	}

	// obj type is float and arg is numeric, accept
	if o.Type.Kind.IsFloat() && a.IsNumeric() {
		return true
	}

	// both are integers, accept
	if o.Type.Kind.IsInteger() && a.Type == rules.ARG_INT {
		return true
	}

	// obj type is unsigned and arg is not negative, accept
	if o.Type.Kind.IsUnsigned() && a.IsUInt() {
		return true
	}

	// arg is string & a Go string literal can be converted to obj type, accept
	if a.Type == rules.ARG_STRING {
		tt := &types.Type{Kind: types.STRING}
		if tt.IsConvertibleTo(o.Type) {
			return true
		}
	}

	return false
}

// NOTE(mkopriva): while not identical to, this does share some logic
// with validateArgOptsAsFuncParams. If something in that logic changes,
// make sure to keep it in sync.
func (c *checker) canUseRuleArgsAsFuncParams(r *rules.Rule) error {
	fn := specs.GetFunc(r.Spec)
	params := fn.Type.In
	firstParamIsField := (r.Spec.Kind != rules.METHOD)

	if firstParamIsField && (len(fn.Type.In) > 1 || !fn.Type.IsVariadic) {
		// Drop the first parameter (the field) if there is more
		// than one parameter, or if the function is non-variadic.
		params = fn.Type.In[1:]
	}

	for i := range r.Args {
		var j int
		var p *types.Var

		switch last := len(params) - 1; {
		case i < last || (i == last && !fn.Type.IsVariadic):
			j = i
			p = params[j]

		case i >= last && fn.Type.IsVariadic:
			j = last
			p = &types.Var{
				Name: params[j].Name,
				Type: params[j].Type.Elem.Type,
			}

		case i > last && r.Spec.JoinOp > 0:
			if len(r.Args)-i >= len(params) {
				j = i % len(params)
				p = params[j]
			}
		}
		if p == nil {
			// NOTE this relies on the fact that ArgOpts is
			// constructured from the rule's Args *after* it
			// has been confirmed, with isValidNumberOfArgs,
			// that the number of Args is ok, given the
			// associated function's type.
			panic("shouldn't reach")
		}

		if !c.canConvertRuleArg(&types.Obj{Type: p.Type}, r.Args[i]) {
			return &Error{r: r, ra: r.Args[i], fp: p, fpi: &j}
		}
	}
	return nil
}

// checkIncludedRuleArgValues is used to validate the literal arguments
// provided to the rules of the github.com/frk/valid package.
func (c *checker) checkIncludedRuleArgValues(r *rules.Rule) error {
	if len(r.Args) == 0 { // no args to check?
		return nil
	}

	// The majority of the included rules need only their
	// first argument checked, the rest will be handled on
	// a per-rule basis.
	var a0 *rules.Arg
	if len(r.Args) > 0 && !r.Args[0].IsFieldRef() {
		a0 = r.Args[0]
	}

	switch r.Spec.Name {

	// both alpha & alnum expect an ISO-639 language code as argument
	case "alpha", "alnum":
		if a0 != nil && !valid.ISO639(a0.Value, 0) {
			p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
			return &Error{r: r, ra: a0, fp: p, fpi: &pi}
		}

	// ccy expects a valid ISO-4217 currency code as argument
	case "ccy":
		if a0 != nil && !valid.ISO4217(a0.Value) {
			p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
			return &Error{r: r, ra: a0, fp: p, fpi: &pi}
		}

	// decimal expects a cldr-supported locale as argument
	case "decimal":
		if a0 != nil {
			if _, ok := cldr.Locale(a0.Value); !ok {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// hash expects an argument present in the HashAlgoLen table
	case "hash":
		if a0 != nil {
			if _, ok := tables.HashAlgoLen[a0.Value]; !ok {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// ip expects an integer specifying a valid ip version as
	// argument, additionally the value 0 is also accepted which
	// allows the validation to validate against all versions
	case "ip":
		if a0 != nil {
			if a0.Value != "4" && a0.Value != "6" && a0.Value != "0" {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// isbn expects an integer specifying a valid isbn version as
	// argument, additionally the value 0 is also accepted which
	// allows the validation to validate against all versions
	case "isbn":
		if a0 != nil {
			if a0.Value != "10" && a0.Value != "13" && a0.Value != "0" {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// iso639 expects an integer specifying a valid iso639 version as
	// argument, additionally the value 0 is also accepted which allows
	// the validation to validate against all versions
	case "iso639":
		if a0 != nil {
			if a0.Value != "1" && a0.Value != "2" && a0.Value != "0" {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// iso31661a expects an integer specifying a valid iso31661a version as
	// argument, additionally the value 0 is also accepted which allows the
	// validation to validate against all versions
	case "iso31661a":
		if a0 != nil {
			if a0.Value != "2" && a0.Value != "3" && a0.Value != "0" {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// mac expects an integer specifying a valid mac version as argument,
	// additionally the value 0 is also accepted which allows the validation
	// to validate against all versions
	case "mac":
		if a0 != nil {
			if a0.Value != "6" && a0.Value != "8" && a0.Value != "0" {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// re expects a valid regular expression as argument
	case "re":
		if a0 != nil {
			if _, err := regexp.Compile(a0.Value); err != nil {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi, err: err}
			}
		}

		// If the "re" rule is present then the file will need
		// to import the github.com/frk/valid package to gain
		// access to the registry function.
		c.file.addImport(types.Pkg{Path: "github.com/frk/valid"})

	// uuid expects an integer specifying a supported uuid version
	case "uuid":
		if a0 != nil {
			if a0.Value != "3" && a0.Value != "4" && a0.Value != "5" {
				p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
				return &Error{r: r, ra: a0, fp: p, fpi: &pi}
			}
		}

	// phone, var, and zip all expect a valid ISO-3166-1A country code
	case "phone", "vat", "zip":
		if a0 != nil && !valid.ISO31661A(a0.Value, 0) {
			p, pi := specs.GetFuncParamByArgIndex(r.Spec, 0)
			return &Error{r: r, ra: a0, fp: p, fpi: &pi}
		}
	}
	return nil
}

// consolidateRuleArgs updates the rule's args based on arg opts specified in the spec.
func (c *checker) consolidateRuleArgs(r *rules.Rule) {
	for i, opts := range r.Spec.ArgOpts {
		if len(r.Args) <= i {
			// If no rule arg was provided at the ith index
			// then initialize it to an "unknown" and see if
			// the opts contains a default (key="") entry.
			a := &rules.Arg{Type: rules.ARG_UNKNOWN}
			if opt, ok := opts[""]; ok {
				*a = opt
			}
			r.Args = append(r.Args, a)
			continue
		}

		a := r.Args[i]

		// If the the rule's argument is "unknown" and
		// the opts contain a default (key="") entry,
		// then update the argument with the default.
		if a.Value == "" && a.Type == rules.ARG_UNKNOWN {
			if opt, ok := opts[""]; ok {
				*a = opt
			}
			continue
		}

		if !a.IsFieldRef() {
			// If a Arg's non-field Value matches an entry
			// in the opts map, then update the Arg.
			if opt, ok := opts[a.Value]; ok {
				*a = opt
			}
		}
	}

	for i, a := range r.Args {
		c.ty.ArgRuleMap[a] = r
		c.ty.ArgIndexMap[a] = i
	}
}

////////////////////////////////////////////////////////////////////////////////

func (c *checker) hasCustomErrorHandler() bool {
	return global.ErrorAggregator != nil ||
		global.ErrorConstructor != nil ||
		c.v.ErrorHandlerField != nil
}

func (c *checker) addDefaultErrorImport(r *rules.Rule) {
	// If the validator doesn't use a custom error handler then the file
	// will need to import either the "errors" package, or the "fmt" package,
	// depending on whether or not the rule has WithArgs, and one or more of
	// those args is a field reference.
	if r.Spec.Err.WithArgs {
		for _, a := range r.Args {
			if a.IsFieldRef() {
				c.file.addImport(types.Pkg{Path: "fmt"})
				return
			}
		}
	}
	c.file.addImport(types.Pkg{Path: "errors"})
}

////////////////////////////////////////////////////////////////////////////////

// addRegExpr adds a new regular expression string to the RxMap.
func (f *FileInfo) addRegExpr(a *rules.Arg) {
	if f.RxMap == nil {
		f.RxMap = make(map[string]int)
	}

	if _, ok := f.RxMap[a.Value]; !ok {
		f.RxMap[a.Value] = len(f.RxMap)
	}
}

// addImport adds a new PkgInfo to the f.Import set.
func (f *FileInfo) addImport(pkg types.Pkg) {
	if _, ok := f.Import[pkg.Path]; ok {
		return
	}

	if f.Import == nil {
		f.Import = make(map[string]*PkgInfo)
	}

	if pkg.Name == "" {
		pkg.Name = pkg.Path
		if i := strings.LastIndexByte(pkg.Name, '/'); i > -1 {
			pkg.Name = pkg.Name[i+1:]
		}
	}

	p := &PkgInfo{Path: pkg.Path, Name: pkg.Name}
	for _, q := range f.Import {
		if p.Name == q.Name {
			q.num += 1
			p.Name = p.Name + strconv.Itoa(q.num)
			p.Local = true
		}
	}

	f.Import[p.Path] = p
}

////////////////////////////////////////////////////////////////////////////////

type errOpts Error

func (c *checker) err(err error, opts errOpts) error {
	e, ok := err.(*Error)
	if !ok {
		return err
	}

	if opts.C > 0 {
		e.C = opts.C
	}
	if e.sf == nil && opts.sf != nil {
		e.sf = opts.sf
	}
	if opts.ty != nil {
		e.ty = opts.ty
	}
	if opts.tag != nil {
		e.tag = opts.tag
	}
	if opts.r != nil {
		e.r = opts.r
	}
	if opts.r2 != nil {
		e.r2 = opts.r2
	}
	if opts.ra != nil {
		e.ra = opts.ra
	}
	if opts.fp != nil {
		e.fp = opts.fp
	}
	if opts.fpi != nil {
		e.fpi = opts.fpi
	}
	if opts.err != nil {
		e.err = opts.err
	}

	if e.ra != nil && e.raf == nil {
		e.raf = c.ty.FRefMap[e.ra]
	}
	return e
}
