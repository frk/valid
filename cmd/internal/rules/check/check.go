package check

import (
	"log"
	"regexp"
	"strconv"

	"github.com/frk/valid"
	"github.com/frk/valid/cmd/internal/config"
	"github.com/frk/valid/cmd/internal/rules/spec"
	"github.com/frk/valid/cmd/internal/rules/v2"
	"github.com/frk/valid/cmd/internal/search"
	"github.com/frk/valid/cmd/internal/types"
	"github.com/frk/valid/internal/cldr"
	"github.com/frk/valid/internal/tables"
)

var _ = log.Println

type Config struct {
	AST      *search.AST
	FieldKey *config.FieldKeyConfig
}

type Info struct {
	// The Validtor struct being rule-checked.
	Validator *types.Validator
	// EnumMap maps types to their declared constants.
	EnumMap map[*types.Type][]types.Const
	// RuleMap maps objects to their corresponding rule set.
	RuleMap map[*types.Obj]*rules.Set
	// SpecMap maps rules to their corresponding specs.
	SpecMap map[*rules.Rule]*spec.Spec
	// FKeyMap maps fields to their corresponding
	// keys as generated by the FieldKeyFunc.
	FKeyMap map[*types.StructField]string
	// FRefMap maps rule args of type ARG_FIELD_{ABS|REL}
	// to the fields that they are referencing.
	FRefMap map[*rules.Arg]*types.StructField
	// FDepMap maps fields to a list of fields on which they depend.
	FDepMap map[*types.StructField][]*types.StructField
	// ChainMap maps each field to its corresponding field chain.
	ChainMap map[*types.StructField]types.FieldChain
}

func Check(cfg Config, match *search.Match, info *Info) error {
	v := types.AnalyzeValidator(match.Named, cfg.AST)

	info.EnumMap = make(map[*types.Type][]types.Const)
	info.RuleMap = make(map[*types.Obj]*rules.Set)
	info.SpecMap = make(map[*rules.Rule]*spec.Spec)
	info.FKeyMap = make(map[*types.StructField]string)
	info.FRefMap = make(map[*rules.Arg]*types.StructField)
	info.FDepMap = make(map[*types.StructField][]*types.StructField)
	info.ChainMap = make(map[*types.StructField]types.FieldChain)

	c := &checker{Info: info, v: v, ast: cfg.AST}
	c.newFKey = makeFKFunc(cfg.FieldKey)
	if err := c.run(); err != nil {
		return c.err(err, errOpts{})
	}

	info.Validator = v
	return nil
}

type checker struct {
	*Info
	// The Validtor struct being rule-checked.
	v *types.Validator
	// The function used for generating unique field keys.
	newFKey FieldKeyFunc
	// Reference to the AST, used for additional type
	// related info retrieval.
	ast *search.AST
}

func (c *checker) run() error {
	if err := c.walkType(c.v.Type); err != nil {
		return err
	}

	if err := c.checkObj(&types.Obj{c.v.Type}); err != nil {
		return err
	}

	// TODO check for cyclic dependencies:
	// i.e., field F has rule arg that references field G
	// and field G has rule arg that references field F
	// should be disallowed....
	return nil
}

func (c *checker) checkObj(o *types.Obj) error {
	if err := c.checkObjRules(o); err != nil {
		return err
	}

	switch t := o.Type; t.Kind {
	case types.PTR:
		return c.checkObj(t.Elem)
	case types.ARRAY, types.SLICE:
		return c.checkObj(t.Elem)
	case types.MAP:
		if err := c.checkObj(t.Key); err != nil {
			return err
		}
		if err := c.checkObj(t.Elem); err != nil {
			return err
		}
	case types.STRUCT:
		for _, f := range t.Fields {
			if f.CanSkip(c.v.Type.Pkg) {
				continue
			}

			if err := c.checkObj(f.Obj); err != nil {
				return c.err(err, errOpts{sf: f})
			}
		}
	}
	return nil
}

func (c *checker) checkObjRules(o *types.Obj) error {
	rs := c.RuleMap[o]
	if rs == nil {
		return nil
	}

	for _, r := range rs.Is.Rules {
		s := c.Info.SpecMap[r]

		if err := c.checkArgSpec(o, r, s); err != nil {
			return err
		}

		var err error
		switch s.Kind {
		case spec.REQUIRED:
			err = c.checkRequired(o, r, s)
		case spec.COMPARABLE:
			err = c.checkComparable(o, r, s)
		case spec.ORDERED:
			err = c.checkOrdered(o, r, s)
		case spec.LENGTH:
			err = c.checkLength(o, r, s)
		case spec.RANGE:
			err = c.checkRange(o, r, s)
		case spec.ENUM:
			err = c.checkEnum(o, r, s)
		case spec.FUNCTION:
			err = c.checkFunction(o, r, s)
		case spec.METHOD:
			err = c.checkMethod(o, r, s)
		case spec.OPTIONAL:
			err = c.checkOptional(o, r, s)
		case spec.REMOVE:
			// err = c.checkRemove(o, r, s)
		}
		if err != nil {
			return err
		}
	}

	for _, r := range rs.Pre.Rules {
		s := c.Info.SpecMap[r]
		if s.Kind != spec.PREPROC {
			return &Error{C: E_PREPROC_INVALID, ty: o.Type, r: r, rs: s}
		}

		if err := c.checkArgSpec(o, r, s); err != nil {
			return err
		}
		if err := c.checkPreprocessor(o, r, s); err != nil {
			return err
		}
	}
	return nil
}

// Check that the number of arguments provided to the rule is allowed by the spec.
func (c *checker) checkArgSpec(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	c.consolidateRuleArgs(r, s)

	if s.ArgMin > -1 && s.ArgMin > len(r.Args) {
		if r.Name == "uuid" {
			log.Printf("******** spec: %#v\n", s)
		}
		return &Error{C: E_RULE_ARGMIN, ty: o.Type, r: r, rs: s}
	}
	if s.ArgMax > -1 && s.ArgMax < len(r.Args) {
		return &Error{C: E_RULE_ARGMAX, ty: o.Type, r: r, rs: s}
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////
// spec.Kind specific rule checks

// checkRequired checks that the REQUIRED rule can be applied to the object.
func (c *checker) checkRequired(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	// when "notnil" is used, the type must be nilable
	if r.Name == "notnil" && !o.Type.IsNilable() {
		return &Error{C: E_NOTNIL_TYPE, ty: o.Type, r: r, rs: s}
	}

	// the "required" rule doesn't need any checking atm

	return nil
}

// checkComparable checks that the rule's arguments can be converted
// to a Go value of a type that is *comparable* with the object's type.
func (c *checker) checkComparable(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	for _, a := range r.Args {
		if !c.canConvertRuleArg(o, a) {
			return &Error{C: E_ARG_BADCMP, ty: o.Type, r: r, rs: s, ra: a}
		}
	}
	return nil
}

// checkOrdered checks that the object's type is *ordered* and that the rule's
// arguments can be converted to a Go value of a type that is *comparable* with
// the object's type.
func (c *checker) checkOrdered(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	// the type must be numeric or string
	if !o.Type.Kind.IsNumeric() && o.Type.Kind != types.STRING {
		return &Error{C: E_ORDERED_TYPE, ty: o.Type, r: r, rs: s}
	}

	// rule args must be comparable with o.Type
	for _, a := range r.Args {
		if !c.canConvertRuleArg(o, a) {
			return &Error{C: E_ORDERED_ARGTYPE, ty: o.Type, r: r, rs: s, ra: a}
		}
	}
	return nil
}

// checkLength checks that the object and rule can be used to generate a "length" rule.
func (c *checker) checkLength(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	switch r.Name {
	case "len":
		// object type must have length
		if !o.Type.HasLength() {
			return &Error{C: E_LENGTH_NOLEN, ty: o.Type, r: r, rs: s}
		}
	case "runecount":
		// object type must be string or byte slice
		if o.Type.Kind != types.STRING && !o.Type.IsBytesOrRunes() {
			return &Error{C: E_LENGTH_NORUNE, ty: o.Type, r: r, rs: s}
		}
	}

	// Make sure that at least one arg was provided.
	if (len(r.Args) == 2 && r.Args[0].IsEmpty() && r.Args[1].IsEmpty()) ||
		(len(r.Args) == 1 && r.Args[0].IsEmpty()) {
		return &Error{C: E_LENGTH_NOARG, ty: o.Type, r: r, rs: s}
	}

	// If two args were provided and both are uint values, then make
	// sure that those values represent valid lower to upper bounds.
	if len(r.Args) == 2 && r.Args[0].IsUInt() && r.Args[1].IsUInt() {
		bounds := [2]uint64{}
		for i, a := range r.Args {
			u64, err := strconv.ParseUint(a.Value, 10, 64)
			if err != nil {
				panic(err.Error()) // this shouldn't happen
			}
			bounds[i] = u64
		}

		if bounds[0] >= bounds[1] {
			return &Error{C: E_LENGTH_BOUNDS, ty: o.Type, r: r, rs: s}
		}
		return nil
	}

	for _, a := range r.Args {
		switch {
		case a.Type == rules.ARG_UNKNOWN:
			continue

		// If the argument is a field then make sure that that field's
		// type can be converted to an int, which is the type of the
		// return value of the `len` and `ut8.RuneCount` functions.
		case a.IsFieldRef():
			tt := &types.Type{Kind: types.INT}
			ft := c.Info.FRefMap[a].Obj.Type // field's type
			if !ft.IsConvertibleTo(tt) {
				return &Error{C: E_LENGTH_ARGTYPE, r: r, ra: a, rs: s}
			}
			continue

		case !a.IsUInt():
			return &Error{C: E_LENGTH_ARGTYPE, r: r, ra: a, rs: s}
		}
	}

	// TODO-maybe: based on arg combination
	// link the ErrOpts[<args>] to the rule.
	return nil
}

// checkRange checks that the object and rule can be used to generate a "range" rule.
func (c *checker) checkRange(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	// object type must be numeric
	if !o.Type.Kind.IsNumeric() {
		return &Error{C: E_RANGE_TYPE, ty: o.Type, r: r, rs: s}
	}

	// Make sure that both args were provided.
	if r.Args[0].IsEmpty() || r.Args[1].IsEmpty() {
		return &Error{C: E_RANGE_NOARG, ty: o.Type, r: r, rs: s}
	}

	// The rule's args must be comparable to the object's type.
	for _, a := range r.Args {
		if !c.canConvertRuleArg(o, a) {
			return &Error{C: E_RANGE_ARGTYPE, ty: o.Type, r: r, rs: s, ra: a}
		}
	}

	// If both args are numeric constants, then make sure
	// that the values represent valid upper to lower bounds.
	if r.Args[0].IsNumeric() && r.Args[1].IsNumeric() {
		bounds := [2]float64{}
		for i := range r.Args {
			f64, err := strconv.ParseFloat(r.Args[i].Value, 64)
			if err != nil {
				panic(err.Error()) // shouldn't happen
			}
			bounds[i] = f64
		}
		if bounds[0] >= bounds[1] {
			return &Error{C: E_RANGE_BOUNDS, ty: o.Type, r: r, rs: s}
		}
	}
	return nil
}

// checkEnum checks that the "enum" rule can be applied to the object's type.
func (c *checker) checkEnum(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	if len(o.Type.Name) == 0 {
		return &Error{C: E_ENUM_NONAME, ty: o.Type, r: r, rs: s}
	}
	if !o.Type.Kind.IsBasic() {
		return &Error{C: E_ENUM_KIND, ty: o.Type, r: r, rs: s}
	}

	// Make sure that the type actually has some accessible constants declared.
	consts := c.Info.EnumMap[o.Type]
	if len(consts) == 0 {
		return &Error{C: E_ENUM_NOCONST, ty: o.Type, r: r, rs: s}
	}
	return nil
}

// checkFunction checks that the object can actually be passed as argument
// to the function. It also checks that the rule arguments can be passed as
// function arguments. In addition to that, if the function belongs to one
// of the included github.com/frk/valid rules, the checker will check the
// validity of the rule's arguments (where possible).
func (c *checker) checkFunction(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	// Check if an instance of the object can be passed
	// to the function as its first argument.
	p := s.FType.In[0].Type
	if s.FType.IsVariadic && len(s.FType.In) == 1 {
		p = p.Elem.Type
	}
	if !o.Type.IsConvertibleTo(p) {
		return &Error{C: E_FUNCTION_INTYPE, ty: o.Type, r: r, rs: s}
	}

	// Check that the arguments specified in the rule tag can be used
	// as the arguments for the corresponding function parameters.
	if err := c.canUseRuleArgsAsFuncParams(r, s); err != nil {
		return c.err(err, errOpts{C: E_FUNCTION_ARGTYPE, ty: o.Type})
	}

	// Some included functions accept arguments of a known set of valid
	// values, check that the rule argument's values belong to that set.
	if s.FType.IsIncluded() {
		if err := c.checkIncludedRuleArgValues(r, s); err != nil {
			return c.err(err, errOpts{C: E_FUNCTION_ARGVALUE, ty: o.Type})
		}
	}

	return nil
}

// checkMethod checks that the object can be used to
// generate a call to the rule's method, e.g. "IsValid".
func (c *checker) checkMethod(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	// Check that o implements a method that matches the rule type.
	var found bool
	for _, m := range o.Type.MethodSet {
		if m.Name != s.FName {
			continue
		}
		if !m.Type.IsIdenticalTo(s.FType) {
			continue
		}

		found = true
		break
	}
	if !found {
		return &Error{C: E_METHOD_TYPE, ty: o.Type, r: r, rs: s}
	}

	// Check that the arguments specified in the rule tag can be used
	// as the arguments for the corresponding method parameters.
	if err := c.canUseRuleArgsAsFuncParams(r, s); err != nil {
		// TODO would be nice to have a test case for this
		// but for that I'd need to add other METHOD rules
		// since currently there's only one and that one
		// takes no input arguments.
		return err
	}

	return nil
}

// checkOptional checks that the use of the optional rule is sound.
func (c *checker) checkOptional(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	rs := c.Info.RuleMap[o]

	if r.Name == "optional" {
		for _, r2 := range rs.Is.Rules {
			if r2.Name == "required" || r2.Name == "notnil" {
				return &Error{C: E_OPTIONAL_CONFLICT, ty: o.Type, r: r, r2: r2, rs: s}
			}
		}
	}
	if r.Name == "omitnil" {
		for _, r2 := range rs.Is.Rules {
			if r2.Name == "notnil" {
				return &Error{C: E_OPTIONAL_CONFLICT, ty: o.Type, r: r, r2: r2, rs: s}
			}
		}
	}
	return nil
}

// checkPreprocessor checks that the object can be passed as argument to the preprocessor
// function and that that function's result can, in turn, be assigned to the object.
func (c *checker) checkPreprocessor(o *types.Obj, r *rules.Rule, s *spec.Spec) error {
	// Make sure that an instance of o can be passed
	// to the function as its first argument.
	paramType := s.FType.In[0].Type
	if s.FType.IsVariadic && len(s.FType.In) == 1 {
		paramType = paramType.Elem.Type
	}
	if !o.Type.IsConvertibleTo(paramType) {
		return &Error{C: E_PREPROC_INTYPE, ty: o.Type, r: r, rs: s}
	}

	// Make sure that an instance of the function
	// output type can be assign to o.
	outputType := s.FType.Out[0].Type
	if !outputType.IsConvertibleTo(o.Type) {
		return &Error{C: E_PREPROC_OUTTYPE, ty: o.Type, r: r, rs: s}
	}

	// Check that the arguments specified in the rule tag can be used
	// as the arguments for the corresponding function's parameters.
	if err := c.canUseRuleArgsAsFuncParams(r, s); err != nil {
		return c.err(err, errOpts{C: E_PREPROC_ARGTYPE, ty: o.Type})
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////
// helpers

// canConvertRuleArg reports whether or not the rule argument's
// literal value can be converted to the object's type.
func (c *checker) canConvertRuleArg(o *types.Obj, a *rules.Arg) bool {
	if a.IsFieldRef() {
		f := c.Info.FRefMap[a]

		// If obj's type is a pointer and the referenced field's type
		// is identical to the pointer's base, then accept because the
		// generator can use deref expression.
		if o.Type.Kind == types.PTR {
			if o.Type.Elem.Type.IsIdenticalTo(f.Obj.Type) {
				return true
			}
		}

		return f.Obj.Type.IsConvertibleTo(o.Type)
	}

	// obj type is interface{} or string, accept
	if o.Type.IsEmptyIface() || o.Type.Kind == types.STRING {
		return true
	}

	// arg is unknown, accept
	if a.Type == rules.ARG_UNKNOWN {
		return true
	}

	// both are booleans, accept
	if o.Type.Kind == types.BOOL && a.Type == rules.ARG_BOOL {
		return true
	}

	// obj type is float and arg is numeric, accept
	if o.Type.Kind.IsFloat() && a.IsNumeric() {
		return true
	}

	// both are integers, accept
	if o.Type.Kind.IsInteger() && a.Type == rules.ARG_INT {
		return true
	}

	// obj type is unsigned and arg is not negative, accept
	if o.Type.Kind.IsUnsigned() && a.IsUInt() {
		return true
	}

	// arg is string & a Go string literal can be converted to obj type, accept
	if a.Type == rules.ARG_STRING {
		tt := &types.Type{Kind: types.STRING}
		if tt.IsConvertibleTo(o.Type) {
			return true
		}
	}

	return false
}

// NOTE(mkopriva): while not identical to, this does share some logic
// with validateArgOptsAsFuncParams. If something in that logic changes,
// make sure to keep it in sync.
func (c *checker) canUseRuleArgsAsFuncParams(r *rules.Rule, s *spec.Spec) error {
	params := s.FType.In
	firstParamIsField := (s.Kind != spec.METHOD)

	if firstParamIsField && (len(s.FType.In) > 1 || !s.FType.IsVariadic) {
		// Drop the first parameter (the field) if there is more
		// than one parameter, or if the function is non-variadic.
		params = s.FType.In[1:]
	}

	for i := range r.Args {
		var j int
		var p *types.Var

		switch last := len(params) - 1; {
		case i < last || (i == last && !s.FType.IsVariadic):
			j = i
			p = params[j]

		case i >= last && s.FType.IsVariadic:
			j = last
			p = &types.Var{
				Name: params[j].Name,
				Type: params[j].Type.Elem.Type,
			}

		case i > last && s.JoinOp > 0:
			if len(r.Args)-i >= len(params) {
				j = i % len(params)
				p = params[j]
			}
		}
		if p == nil {
			// NOTE this relies on the fact that ArgOpts is
			// constructured from the rule's Args *after* it
			// has been confirmed, with isValidNumberOfArgs,
			// that the number of Args is ok, given the
			// associated function's type.
			panic("shouldn't reach")
		}

		if !c.canConvertRuleArg(&types.Obj{p.Type}, r.Args[i]) {
			return &Error{r: r, rs: s, ra: r.Args[i], fp: p, fpi: &j}
		}
	}
	return nil
}

// checkIncludedRuleArgValues is used to validate the literal arguments
// provided to the rules of the github.com/frk/valid package.
func (c *checker) checkIncludedRuleArgValues(r *rules.Rule, s *spec.Spec) error {
	if len(r.Args) == 0 { // no args to check?
		return nil
	}

	// The majority of the included rules need only their
	// first argument checked, the rest will be handled on
	// a per-rule basis.
	var a0 *rules.Arg
	if len(r.Args) > 0 && !r.Args[0].IsFieldRef() {
		a0 = r.Args[0]
	}

	switch s.Name {

	// both alpha & alnum expect an ISO-639 language code as argument
	case "alpha", "alnum":
		if a0 != nil && !valid.ISO639(a0.Value, 0) {
			p, pi := s.GetFuncParamByArgIndex(0)
			return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
		}

	// ccy expects a valid ISO-4217 currency code as argument
	case "ccy":
		if a0 != nil && !valid.ISO4217(a0.Value) {
			p, pi := s.GetFuncParamByArgIndex(0)
			return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
		}

	// decimal expects a cldr-supported locale as argument
	case "decimal":
		if a0 != nil {
			if _, ok := cldr.Locale(a0.Value); !ok {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// hash expects an argument present in the HashAlgoLen table
	case "hash":
		if a0 != nil {
			if _, ok := tables.HashAlgoLen[a0.Value]; !ok {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// ip expects an integer specifying a valid ip version as
	// argument, additionally the value 0 is also accepted which
	// allows the validation to validate against all versions
	case "ip":
		if a0 != nil {
			if a0.Value != "4" && a0.Value != "6" && a0.Value != "0" {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// isbn expects an integer specifying a valid isbn version as
	// argument, additionally the value 0 is also accepted which
	// allows the validation to validate against all versions
	case "isbn":
		if a0 != nil {
			if a0.Value != "10" && a0.Value != "13" && a0.Value != "0" {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// iso639 expects an integer specifying a valid iso639 version as
	// argument, additionally the value 0 is also accepted which allows
	// the validation to validate against all versions
	case "iso639":
		if a0 != nil {
			if a0.Value != "1" && a0.Value != "2" && a0.Value != "0" {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// iso31661a expects an integer specifying a valid iso31661a version as
	// argument, additionally the value 0 is also accepted which allows the
	// validation to validate against all versions
	case "iso31661a":
		if a0 != nil {
			if a0.Value != "2" && a0.Value != "3" && a0.Value != "0" {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// mac expects an integer specifying a valid mac version as argument,
	// additionally the value 0 is also accepted which allows the validation
	// to validate against all versions
	case "mac":
		if a0 != nil {
			if a0.Value != "6" && a0.Value != "8" && a0.Value != "0" {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// re expects a valid regular expression as argument
	case "re":
		if a0 != nil {
			if _, err := regexp.Compile(a0.Value); err != nil {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi, err: err}
			}
		}

	// uuid expects an integer specifying a supported uuid version
	case "uuid":
		if a0 != nil {
			if a0.Value != "3" && a0.Value != "4" && a0.Value != "5" {
				p, pi := s.GetFuncParamByArgIndex(0)
				return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
			}
		}

	// phone, var, and zip all expect a valid ISO-3166-1A country code
	case "phone", "vat", "zip":
		if a0 != nil && !valid.ISO31661A(a0.Value, 0) {
			p, pi := s.GetFuncParamByArgIndex(0)
			return &Error{r: r, rs: s, ra: a0, fp: p, fpi: &pi}
		}
	}
	return nil
}

// consolidateRuleArgs updates the rule's args based on arg opts specified in the spec.
func (c *checker) consolidateRuleArgs(r *rules.Rule, s *spec.Spec) {
	for i, opts := range s.ArgOpts {
		if len(r.Args) <= i {
			// If no rule arg was provided at the ith index
			// then initialize it to an "unknown" and see if
			// the opts contains a default (key="") entry.
			a := &rules.Arg{Type: rules.ARG_UNKNOWN}
			if opt, ok := opts[""]; ok {
				*a = opt
			}
			r.Args = append(r.Args, a)
			continue
		}

		a := r.Args[i]

		// If the the rule's argument is "unknown" and
		// the opts contain a default (key="") entry,
		// then update the argument with the default.
		if a.Value == "" && a.Type == rules.ARG_UNKNOWN {
			if opt, ok := opts[""]; ok {
				*a = opt
			}
			continue
		}

		if !a.IsFieldRef() {
			// If a Arg's non-field Value matches an entry
			// in the opts map, then update the Arg.
			if opt, ok := opts[a.Value]; ok {
				*a = opt
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

type errOpts Error

func (c *checker) err(err error, opts errOpts) error {
	e, ok := err.(*Error)
	if !ok {
		return err
	}

	if opts.C > 0 {
		e.C = opts.C
	}
	if e.sf == nil && opts.sf != nil {
		e.sf = opts.sf
	}
	if opts.ty != nil {
		e.ty = opts.ty
	}
	if opts.tag != nil {
		e.tag = opts.tag
	}
	if opts.r != nil {
		e.r = opts.r
	}
	if opts.r2 != nil {
		e.r2 = opts.r2
	}
	if opts.rs != nil {
		e.rs = opts.rs
	}
	if opts.ra != nil {
		e.ra = opts.ra
	}
	if opts.fp != nil {
		e.fp = opts.fp
	}
	if opts.fpi != nil {
		e.fpi = opts.fpi
	}
	if opts.err != nil {
		e.err = opts.err
	}

	if e.ra != nil && e.raf == nil {
		e.raf = c.Info.FRefMap[e.ra]
	}
	return e
}
