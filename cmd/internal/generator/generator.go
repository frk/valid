package generator

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"

	"github.com/frk/valid/cmd/internal/rules"
	"github.com/frk/valid/cmd/internal/search"
	"github.com/frk/valid/cmd/internal/xtypes"

	GO "github.com/frk/ast/golang"
)

var _ = fmt.Println

// set of pre-declared nodes
var (
	FILE_PREAMBLE = GO.LineComment{` DO NOT EDIT. This file was generated by "github.com/frk/valid".`}
	OK            = GO.Ident{"ok"}
	ERR           = GO.Ident{"err"}
	NIL           = GO.Ident{"nil"}
	ERROR         = GO.Ident{"error"}
	ROOT_RECV     = GO.Ident{"v"}
	BLANK         = GO.Ident{"_"}
)

func Generate(pkg search.Pkg, infos []*rules.Info) ([]byte, error) {
	ast := fileAST(xtypes.Pkg(pkg), infos)
	buffer := new(bytes.Buffer)
	if err := GO.Write(ast, buffer); err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}

// the "global" state of the generator
type gg struct {
	pkg     xtypes.Pkg
	imports []*pkginfo
	init    []*rules.Rule
	info    *rules.Info
	recv    GO.ExprNode
	argmap  map[*rules.Rule][]GO.ExprNode
	enumap  map[*rules.Rule][]GO.ExprNode
}

func (g *gg) block(ast *GO.BlockStmt) bb {
	return bb{g: g,
		ast: ast,
		cur: ast,
		val: g.recv,
	}
}

// The pkginfo type holds info that will be used to generate a GO.ImportSpec node.
type pkginfo struct {
	// The package path of the import spec.
	path string
	// The package name associated with the import spec.
	name string
	// If set, it indicates that the Name field should be set
	// in the generated GO.ImportSpec node.
	local bool
	// Number of package'g with the same name. This value is used by those
	// packages to modify their name in order to not cause an import conflict.
	num int
}

// addImport adds a new pkginfo to the import set if
// it is not already a member of that set.
func (g *gg) addImport(p xtypes.Pkg) *pkginfo {
	if p.Name == "" {
		p.Name = p.Path
		if i := strings.LastIndexByte(p.Name, '/'); i > -1 {
			p.Name = p.Name[i+1:]
		}
	}

	var sameName *pkginfo
	for _, pkg := range g.imports {
		// already added, exit
		if pkg.path == p.Path {
			return pkg
		}

		// retain package that has the same name
		if pkg.name == p.Name {
			sameName = pkg
		}
	}

	pkg := &pkginfo{path: p.Path, name: p.Name}
	if sameName != nil {
		sameName.num += 1
		pkg.name = p.Name + strconv.Itoa(sameName.num)
		pkg.local = true
	}

	g.imports = append(g.imports, pkg)
	return pkg
}

type bb struct {
	g      *gg
	ast    *GO.BlockStmt
	cur    *GO.BlockStmt
	optIfs *GO.IfStmt
	reqIfs *GO.IfStmt
	val    GO.ExprNode
	vals   []GO.ExprNode
	idx    GO.ExprNode
	key    string
	tmp    bool
}

func (b *bb) new() (out bb) {
	return bb{
		g:   b.g,
		ast: b.cur,
		cur: b.cur,
		val: b.val,
		idx: b.idx,
		key: b.key,
	}
}

func (b *bb) with(val GO.ExprNode) (out bb) {
	return bb{
		g:   b.g,
		ast: b.ast,
		cur: b.cur,
		idx: b.idx,
		val: val,
		key: b.key,
	}
}

func (b *bb) field(f *rules.FieldNode) (out bb) {
	if f.Field.IsEmbedded {
		return bb{
			g:   b.g,
			ast: b.ast,
			cur: b.cur,
			idx: b.idx,
			val: b.val,
			key: b.key,
		}
	}

	return bb{
		g:   b.g,
		ast: b.ast,
		cur: b.cur,
		idx: b.idx,
		val: GO.SelectorExpr{X: b.val, Sel: GO.Ident{f.Field.Name}},
		key: f.Key,
	}
}

func (b *bb) add(s GO.StmtNode) {
	b.cur.Add(s)
}

func (b *bb) use(s *GO.BlockStmt) {
	b.cur = s
}

func (b *bb) pind() {
	b.vals = append(b.vals, b.val)
	b.val = GO.PointerIndirectionExpr{b.val}
}

func (b *bb) pund() {
	b.val = b.vals[len(b.vals)-1]
	b.vals = b.vals[:len(b.vals)-1]
}

func (b *bb) rootv() GO.ExprNode {
	if !b.tmp && len(b.vals) > 0 {
		return b.vals[0]
	}
	return b.val
}

func (b *bb) tempVar() {
	val := GO.Ident{"f"}
	b.add(GO.AssignStmt{Token: GO.AssignDefine, Lhs: val, Rhs: b.val})
	b.val = val
	b.tmp = true
}

func (b *bb) subBlock() {
	sub := &GO.BlockStmt{}
	b.add(sub)
	b.use(sub)
}
