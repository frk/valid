package generate

import (
	"fmt"

	"github.com/frk/valid/cmd/internal/rules/checker"
)

func File(fi *checker.FileInfo) ([]byte, error) {
	g := (&gg{}).init()
	g.L(`// Code generated by "github.com/frk/valid". DO NOT EDIT.`)
	g.L(``)
	g.L(`package $0`, fi.Pkg)
	g.L(``)
	if len(fi.Import) > 0 {
		g.L(`import (`)
		g.L(`$0`, fi.Import)
		g.L(`)`)
		g.L(``)
	}
	if len(fi.RxMap) > 0 {
		g.L(`func init() {`)
		g.L(`	$0`, fi.RxMap)
		g.L(`}`)
		g.L(``)
	}
	for _, ty := range fi.Types {
		g.L(`func (v *$0) Validate() error {`, ty)
		g.L(`	$0`, ty)
		g.L(`}`)
		g.L(``)
	}

	return nil, nil
}

type gg struct {
	// recieve tokens from scanners
	tokens chan *token
	// current token
	t *token
	// explicitly stop the current scanner
	stop chan struct{}
	// error encountered during parsing
	err error
	// the file (root) node
	f *file
	// the current node
	cur node
}

func (g *gg) init() *gg {
	g.tokens = make(chan *token)
	g.stop = make(chan struct{})
	g.f = new(file)
	g.cur = g.f
	return g
}

func (g *gg) parse(in string, args ...any) error {
	go (&scanner{in: in, out: g.tokens, stop: g.stop}).run()
	return g.build(g.cur, args)
}

func (g *gg) build(n node, args ...any) error {
	if err := g.next(); err != nil {
		return err
	}
	g.cur = n
	return g.cur.build(g, args)
}

// get the next token from the channel
func (g *gg) next() error {
	if g.err != nil {
		return g.err
	}
	if g.t.t == t_eof {
		return nil
	}

	// consume ws up to first non-ws
	for t := range g.tokens {
		if t.t != t_ws {
			g.t = t
			break
		}
	}

	if g.t.t == t_invalid { // bad token?
		g.err = fmt.Errorf("invalid token %q at %d", g.t.v, g.t.p)
		g.stop <- struct{}{}
		return g.err
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////

func (g *gg) L(line string, args ...any) {
	// ...
	// gg: hand of line & input to parser
	// parser: hand of line to scanner
	// scanner: tokenize line
	// parser: construct ast from tokens
}
