package generate

import (
	"github.com/frk/valid/cmd/internal/rules/check"
	"github.com/frk/valid/cmd/internal/search"
	"github.com/frk/valid/cmd/internal/types"
)

// #1 dependencies:
//
// fields should be validate in the same order in which they appear in the struct
// but if a field has a rule arg that references another filed then that referenced
// filed MUST appear before the referencing field
//
// Write a procedure that reorders the fields to satisfies this rule.
// -----------------------------------------------------------------------------
//
//

func File(pkg search.Pkg, infos []*check.Info) ([]byte, error) {

	// 1. generate code for individual validators
	// 2. generate code for file
	//	- package clause
	//	- import statements
	//	- regexp registration
	//	...
	// 3. merge and write file

	file := &fileInfo{
		pkg:   types.Pkg(pkg),
		reMap: make(map[string]int),
		wr:    writer{vars: map[string]string{}},
	}

	for _, info := range infos {
		g := &generator{file: file, info: info}
		g.wr.vars = map[string]string{"x": "v"}
		if err := g.run(); err != nil {
			return nil, err
		}
	}

	file.wr.ln(`// Code generated by "github.com/frk/valid". DO NOT EDIT.`)
	file.wr.nl()
	file.wr.ln(`package $0`, file.pkg.Name)
	file.writeImports()

	// TODO init (regexp registry)

	for _, m := range file.methods {
		file.wr.from(m)
		file.wr.nl()
	}
	if file.wr.err != nil {
		return nil, file.wr.err
	}
	return file.wr.buf.Bytes(), nil
}

type fileInfo struct {
	pkg     types.Pkg
	imports []*pkgInfo
	// A map of regular expressions that need
	// to be registered in the file's init func.
	reMap map[string]int
	// The file writer
	wr writer
	// The writers used to generate the methods
	methods []*writer
}

type generator struct {
	wr   writer
	file *fileInfo
	info *check.Info

	// the current field
	fld *types.StructField
	// the current object
	obj *types.Obj
}

func (g *generator) run() error {
	g.wr.ln("func (v *$0) Validate() error {", g.info.Validator.Type.Name)
	g.genBeforeHook()
	g.genBody()
	g.genAfterHook()
	g.genReturn()
	g.wr.ln("}")

	if g.wr.err != nil {
		return g.wr.err
	}
	g.file.methods = append(g.file.methods, &g.wr)
	return nil
}

func (g *generator) genBeforeHook() {
	// TODO
}

func (g *generator) genBody() {
	for _, f := range g.info.Validator.Type.Fields {
		g.fld = f
		g.obj = f.Obj

		obj := g.genPtrCode(f, f.Obj)
		g.genObjCode(f, obj)
	}
}

func (g *generator) genAfterHook() {
	// TODO
}

func (g *generator) genReturn() {
	g.wr.ln("	return nil")
}

func (g *generator) genObjCode(f *types.StructField, o *types.Obj) {
	if rs, ok := g.info.RuleMap[o]; ok && rs != nil {
		g.ifStmt(rs)
	}

	switch t := o.Type; t.Kind {
	case types.PTR:
		g.obj = t.Elem
		g.genObjCode(f, t.Elem)
	case types.ARRAY, types.SLICE:
		g.obj = t.Elem
		g.genObjCode(f, t.Elem)
	case types.MAP:
		g.obj = t.Key
		g.genObjCode(f, t.Elem)
		g.obj = t.Elem
		g.genObjCode(f, t.Elem)
	case types.STRUCT:
		for _, f := range t.Fields {
			if f.CanSkip(g.info.Validator.Type.Pkg) {
				continue
			}

			g.genPtrCode(f, f.Obj)
			g.genObjCode(f, f.Obj)
		}
	}
}
