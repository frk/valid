package generate

import (
	"bytes"

	"github.com/frk/valid/cmd/internal/rules/checker"
	"github.com/frk/valid/cmd/internal/rules/v2"
	"github.com/frk/valid/cmd/internal/search"
	"github.com/frk/valid/cmd/internal/types"
)

// #1 dependencies:
//
// fields should be validate in the same order in which they appear in the struct
// but if a field has a rule arg that references another filed then that referenced
// filed MUST appear before the referencing field
//
// Write a procedure that reorders the fields to satisfies this rule.
// -----------------------------------------------------------------------------
//
//

func File(pkg search.Pkg, infos []*checker.Info) ([]byte, error) {
	file := new(fileInfo)
	file.pkg = types.Pkg(pkg)

	for _, info := range infos {
		g := new(generator)
		g.file = file
		g.info = info
		g.vars = map[string]string{"x": "v"}
		if err := g.genValidator(); err != nil {
			return nil, err
		}
	}

	// file generator
	fg := new(generator)
	fg.file = file
	fg.vars = map[string]string{"x": "v"}

	fg.L(`// Code generated by "github.com/frk/valid". DO NOT EDIT.`)
	fg.L(``)
	fg.L(`package $0`, file.pkg.Name)
	fg.genImports()
	fg.genInit()
	for _, vm := range file.vms {
		fg.From(vm)
		fg.L(``)
	}
	if fg.werr != nil {
		return nil, fg.werr
	}
	return fg.buf.Bytes(), nil
}

type generator struct {
	buf   bytes.Buffer
	file  *fileInfo
	info  *checker.Info
	vars  map[string]string
	nptr  int   // deref depth
	mixed bool  // mixed rule cond expr?
	werr  error // write error
}

func (g *generator) genValidator() error {
	g.vars["x"] = "v"

	g.L("func ($x *$0) Validate() error {", g.info.Validator.Type.Name)
	g.genBeforeHook()
	g.genBody()
	g.genAfterHook()
	g.genReturn()
	g.L("}")

	if g.werr != nil {
		return g.werr
	}

	g.file.vms = append(g.file.vms, g)
	return nil
}

func (g *generator) genBeforeHook() {
	// TODO
}

func (g *generator) genBody() {
	t := g.info.Validator.Type
	g.genStructBlock(t, no_block)
}

func (g *generator) genAfterHook() {
	// TODO
}

func (g *generator) genReturn() {
	g.L("return nil")
}

func (g *generator) genObjCode(f *types.StructField, o *types.Obj) {
	var ruleblock blockType = if_block
	var elemblock blockType

	if o.Type.Kind == types.PTR {
		switch {
		case o.Has(rules.REQUIRED):
			o = g.genReqCode(f, o)
			elemblock = else_block
		case o.Has(rules.OPTIONAL):
			o = g.genOptCode(f, o)
			ruleblock = elif_block
			elemblock = sub_block
		default:
			// assume "NOGUARD" for which we do not generate if-statements,
			// only the deref-expression should be generated.
			for o.Type.Kind == types.PTR {
				o = o.Type.Elem
				g.deref()
			}
		}
	}

	if len(o.PreRules) > 0 {
		g.genPreRuleBlock(f, o, elemblock)
	}
	if len(o.IsRules) > 0 {
		g.genIsRuleBlock(f, o, ruleblock)
		elemblock = else_block
	}

	switch t := o.Type; t.Kind {
	case types.MAP:
		g.genMapBlock(f, t, elemblock)
	case types.ARRAY, types.SLICE:
		g.genSliceBlock(f, t, elemblock)
	case types.STRUCT:
		g.genStructBlock(t, elemblock)
	}
}

////////////////////////////////////////////////////////////////////////////////

func (g *generator) fsel(x string, f *types.StructField) {
	g.vars["x"] = x + "." + f.Name
	g.nptr = 0
}

func (g *generator) deref() {
	g.vars["x"] = "*" + g.vars["x"]
	g.nptr += 1
}
